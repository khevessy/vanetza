{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Vanetza in a nutshell Vanetza is an open-source implementation of the ETSI C-ITS protocol suite. Among others, it comprises the following protocols and features: GeoNetworking (GN) Basic Transport Protocol (BTP) Decentralized Congestion Control (DCC) Security Support for ASN.1 messages (Facilities) such as CAM and DENM Though originally designed to operate on ITS-G5 channels in a Vehicular Ad Hoc Network (VANET) using IEEE 802.11p, Vanetza and its components can be combined with other communication technologies as well, e.g. GeoNetworking over IP multicast. Project layout In the first place, Vanetza is a conglomerate of C++ libraries, some depending on others. Sources of these libraries, also known as Vanetza component, are bundled in their respective subdirectories. Component Depends on Features access net Access layer, helpers for IEEE 802.11 PHY and MAC asn1 - Generated code and wrappers for ASN.1 based messages, e.g. CAM and DENM btp geonet Headers and interfaces for BTP transport layer common - General purpose classes used across Vanetza components, including serialization and timing dcc access, net Algorithms for DCC cross-layer facilities asn1, geonet, security Helpers to generate and evaluate ITS messages geonet dcc, net, security GeoNetworking layer featuring geographical routing gnss - Satellite navigation integration for positioning net common Utilities for socket API and packet handling rpc access, dcc, net Cap\u2019n Proto RPC client with Boost.Asio support security common, net Security entity to sign and verify packets For most of the code unit tests exist. We are using Googletest for those. Compilation of Vanetza unit tests can be enabled via the BUILD_TESTS CMake option. You can the run those tests in your build directory by executing ctest . Additionally, the tools directory contains several utilities making use of Vanetza libraries. Tool Purpose CMake option benchmark Benchmarking security features, e.g. signing or validating a lot messages in a row BUILD_BENCHMARK certify Utility for generating and handling security certificates, authorization tickets etc. BUILD_CERTIFY socktap Example application using most of the Vanetza stack operating on sockets, i.e. either Linux packet sockets or optionally Cohda LLC sockets BUILD_SOCKTAP Deployments Vanetza has been developed for network simulations and testing on embedded devices at Technische Hochschule Ingolstadt initially. Meanwhile, Vanetza is used by many more parties and for more use cases than anticipated in the beginning. Artery is a V2X simulation framework based on OMNeT++ . Vanetza is used in this network simulation as (quite detailed) model of ITS-G5 protocols. Various communication units (roadside units, vehicles and testbeds) in the CARISSMA Car2X lab are powered by Vanetza. Prototype motorcycles operated by the Connected Motorcycle Consortium use Vanetza for evaluation of novel ITS applications to enhance rider safety. nfiniity integrates its cube V2X ecosystem with Vanetza. If you are using Vanetza, we would love to add your project to the list above. Please write an e-mail to raphael@riebl.net or open a pull request.","title":"Overview"},{"location":"#vanetza-in-a-nutshell","text":"Vanetza is an open-source implementation of the ETSI C-ITS protocol suite. Among others, it comprises the following protocols and features: GeoNetworking (GN) Basic Transport Protocol (BTP) Decentralized Congestion Control (DCC) Security Support for ASN.1 messages (Facilities) such as CAM and DENM Though originally designed to operate on ITS-G5 channels in a Vehicular Ad Hoc Network (VANET) using IEEE 802.11p, Vanetza and its components can be combined with other communication technologies as well, e.g. GeoNetworking over IP multicast.","title":"Vanetza in a nutshell"},{"location":"#project-layout","text":"In the first place, Vanetza is a conglomerate of C++ libraries, some depending on others. Sources of these libraries, also known as Vanetza component, are bundled in their respective subdirectories. Component Depends on Features access net Access layer, helpers for IEEE 802.11 PHY and MAC asn1 - Generated code and wrappers for ASN.1 based messages, e.g. CAM and DENM btp geonet Headers and interfaces for BTP transport layer common - General purpose classes used across Vanetza components, including serialization and timing dcc access, net Algorithms for DCC cross-layer facilities asn1, geonet, security Helpers to generate and evaluate ITS messages geonet dcc, net, security GeoNetworking layer featuring geographical routing gnss - Satellite navigation integration for positioning net common Utilities for socket API and packet handling rpc access, dcc, net Cap\u2019n Proto RPC client with Boost.Asio support security common, net Security entity to sign and verify packets For most of the code unit tests exist. We are using Googletest for those. Compilation of Vanetza unit tests can be enabled via the BUILD_TESTS CMake option. You can the run those tests in your build directory by executing ctest . Additionally, the tools directory contains several utilities making use of Vanetza libraries. Tool Purpose CMake option benchmark Benchmarking security features, e.g. signing or validating a lot messages in a row BUILD_BENCHMARK certify Utility for generating and handling security certificates, authorization tickets etc. BUILD_CERTIFY socktap Example application using most of the Vanetza stack operating on sockets, i.e. either Linux packet sockets or optionally Cohda LLC sockets BUILD_SOCKTAP","title":"Project layout"},{"location":"#deployments","text":"Vanetza has been developed for network simulations and testing on embedded devices at Technische Hochschule Ingolstadt initially. Meanwhile, Vanetza is used by many more parties and for more use cases than anticipated in the beginning. Artery is a V2X simulation framework based on OMNeT++ . Vanetza is used in this network simulation as (quite detailed) model of ITS-G5 protocols. Various communication units (roadside units, vehicles and testbeds) in the CARISSMA Car2X lab are powered by Vanetza. Prototype motorcycles operated by the Connected Motorcycle Consortium use Vanetza for evaluation of novel ITS applications to enhance rider safety. nfiniity integrates its cube V2X ecosystem with Vanetza. If you are using Vanetza, we would love to add your project to the list above. Please write an e-mail to raphael@riebl.net or open a pull request.","title":"Deployments"},{"location":"api/","text":"An API documentation can be generated directly from source code with Doxygen . If Doxygen is installed on your system, you may simply call doxygen in the repository\u2019s root directory. The generated HTML documentation can then be found at doxygen/html/index.html . We also maintain an online copy which is updated every now and then. Of course, your locally generated documentation will be more up-to-date in most cases. Please consider to generate the documentation locally if you need it to match a particular or more recent version of Vanetza.","title":"API Documentation"},{"location":"how-to-build/","text":"How to build Building Vanetza is accomplished by the CMake build system. Hence, CMake needs to be available on the build host. Prerequisites You need following tools and libraries on your system for compiling Vanetza: C++11 compatible compiler, e.g. GNU GCC or Clang CMake 3.12 or higher Boost 1.58 or higher GeographicLib 1.37 or higher Crypto++ 5.6.1 or higher If OpenSSL (1.0 or 1.1) or LibreSSL is available on your system, an alternative security backend implementation is compiled along with the Crypto++ based backend. See security::Backend and security::create_backend for more details. Hint If you are building on Ubuntu 16.04 or 18.04, please note that these Ubuntu releases ship outdated CMake versions unsuitable for Vanetza. Have a look at the Kitware APT Repository , which lists some of your options for installing an up-to-date CMake version. Compilation Following command line snippet demonstrates the build process using a generated Makefile. Other CMake generators and build directory setups can be used as well. cd vanetza mkdir build && cd build cmake .. make Unit tests Vanetza comes with many unit tests covering the most critical parts. When the CMake option BUILD_TESTS is enabled, the Google Test sources are downloaded by the build system automatically. The built test cases are standalone executables located in the tests subdirectory of your build directory. For running all test cases, I recommend to invoke ctest in your build directory. Integrating Vanetza Vanetza is primarily a library project intended for integration by other projects, e.g. V2X simulation tools such as Artery . Projects using CMake can integrate Vanetza most easily by calling find_package(Vanetza) and then refer to the imported Vanetza targets, such as Vanetza::vanetza .","title":"How to build"},{"location":"how-to-build/#how-to-build","text":"Building Vanetza is accomplished by the CMake build system. Hence, CMake needs to be available on the build host.","title":"How to build"},{"location":"how-to-build/#prerequisites","text":"You need following tools and libraries on your system for compiling Vanetza: C++11 compatible compiler, e.g. GNU GCC or Clang CMake 3.12 or higher Boost 1.58 or higher GeographicLib 1.37 or higher Crypto++ 5.6.1 or higher If OpenSSL (1.0 or 1.1) or LibreSSL is available on your system, an alternative security backend implementation is compiled along with the Crypto++ based backend. See security::Backend and security::create_backend for more details. Hint If you are building on Ubuntu 16.04 or 18.04, please note that these Ubuntu releases ship outdated CMake versions unsuitable for Vanetza. Have a look at the Kitware APT Repository , which lists some of your options for installing an up-to-date CMake version.","title":"Prerequisites"},{"location":"how-to-build/#compilation","text":"Following command line snippet demonstrates the build process using a generated Makefile. Other CMake generators and build directory setups can be used as well. cd vanetza mkdir build && cd build cmake .. make","title":"Compilation"},{"location":"how-to-build/#unit-tests","text":"Vanetza comes with many unit tests covering the most critical parts. When the CMake option BUILD_TESTS is enabled, the Google Test sources are downloaded by the build system automatically. The built test cases are standalone executables located in the tests subdirectory of your build directory. For running all test cases, I recommend to invoke ctest in your build directory.","title":"Unit tests"},{"location":"how-to-build/#integrating-vanetza","text":"Vanetza is primarily a library project intended for integration by other projects, e.g. V2X simulation tools such as Artery . Projects using CMake can integrate Vanetza most easily by calling find_package(Vanetza) and then refer to the imported Vanetza targets, such as Vanetza::vanetza .","title":"Integrating Vanetza"},{"location":"legal/","text":"Legal Notice As maintainer of Vanetza, I am responsible for this website\u2019s content under German Law. Following contact details are given to comply with \u00a7 5 TMG and \u00a7 55 Abs. 2 RStV. Feel free to send me a postcard if you like Vanetza :-) Contact Raphael Riebl Bergstra\u00dfe 9 85129 Unterdolling Germany E-mail: raphael@riebl.net I will not answer support requests via e-mail. Please open an issue ticket instead. Privacy Statement I do not collect, store or process any information about visitors of this website. Please note that the API documentation generated by Doxygen sets a non-essential cookie storing your preferred width of its navigation\u2019s sidebar. This website is hosted by GitHub. They likely record some personally identifiable information such as your IP address. Please refer to GitHub\u2019s privacy statement for details. Furthermore, web fonts are included via Google Fonts API . Google has added a section to their FAQ about privacy implications .","title":"Legal Notice"},{"location":"legal/#legal-notice","text":"As maintainer of Vanetza, I am responsible for this website\u2019s content under German Law. Following contact details are given to comply with \u00a7 5 TMG and \u00a7 55 Abs. 2 RStV. Feel free to send me a postcard if you like Vanetza :-)","title":"Legal Notice"},{"location":"legal/#contact","text":"Raphael Riebl Bergstra\u00dfe 9 85129 Unterdolling Germany E-mail: raphael@riebl.net I will not answer support requests via e-mail. Please open an issue ticket instead.","title":"Contact"},{"location":"legal/#privacy-statement","text":"I do not collect, store or process any information about visitors of this website. Please note that the API documentation generated by Doxygen sets a non-essential cookie storing your preferred width of its navigation\u2019s sidebar. This website is hosted by GitHub. They likely record some personally identifiable information such as your IP address. Please refer to GitHub\u2019s privacy statement for details. Furthermore, web fonts are included via Google Fonts API . Google has added a section to their FAQ about privacy implications .","title":"Privacy Statement"},{"location":"recipes/autotalks-sdk-build/","text":"Building Vanetza for Autotalks Craton using Autotalks SDK This document describes building Vanetza for the Autotalks device. There is a difference between building for Craton and Secton. Steps for building Vanetza for Autotalks Craton are very similar to build for Cohda MK5 devices (you can see steps in the building for Cohda MK5 document ). Difference is that there is no virtual machine provided from Autotalks. Autotalks SDK can used only in the socktap example, so you must always compile it when you want the SDK. Autotalks SDK SDK is shipped with Autotalks devices, you should have obtained one. Until Release 18, it was recommended to build the SDK in Ubuntu 16.04, now Ubuntu 18.04 or 20.04 should be used; it was tested on the latter. For Secton, there is used gcc version 9.4.0, for Craton arm-poky-linux-gnueabi-g++ version 11.2.0, that is installed with the poky container. Code corrections With Autotalks SDK version <= 5.15.0, you will have to do a correction in file autotalks_*_api/include/atlk/ddm_service.h on line 615 and add there an explicit cast to stats_tlv_t * . Without this, you won\u2019t be able to build the project because of the -fpermissive flag. As of version 5.16.0, this problem is fixed. In version 5.17 (Release 18), there are another problems: * In autotalks_{craton,secton} api/include/common/counters.h change line 110 from uint8_t data[] to uint8_t* data * In autotalks {craton,secton}_api/include/atlk/generic_compensator.h, there is missing } for the extern \"C\" directive (this should be solved in newer SDK) Another thing you must note is in the initialization in the socktap example. The initialization code in v2x_device_init() was used directly from the example in the Autotalks SDK, therefore it should not be distributed with the library. You will have to write it yourself, but it really is almost the same as main() function in the basic example from the SDK. In the initialization, there is a define for SECTON_NET_NAME . This is a network interface name which determines how is the SoC seen in Linux. It should be enx0002ccf00006 by default, but if it is set to something else, you can change this define. You can use ifconfig output to determine the actual name (see Autotalks documentation for more details). Vanetza build dependencies Please see this document about cross-compiling Vanetza\u2019s dependencies. This guide was tested with precompiled libraries downloadable from here . Compile Vanetza Compiling for Craton We assume you have copy of the Vanetza repository in your home directory at $HOME . Furthermore, there should be a symbolic link named autotalks_craton_api in your home directory, that links to the root of Craton SDK (e.g., from /home/your_user/autotalks_craton_api to the API compilation directory). If you have Poky toolchain installed in other directory than /opt/poky-craton2/4.0.1 (e.g. /tools/gcc/arm/new_toolchain as suggested by Autotalks), change the path in cmake/Toolchain-Autotalks-Craton.cmake. Create a build directory and tell CMake to use the cross-compiler installed on your machine and to look up additional dependencies in vanetza-deps : mkdir vanetza/vanetza-build cd vanetza/vanetza-build cmake .. \\ -DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchain-Autotalks-Craton.cmake \\ -DCMAKE_FIND_ROOT_PATH=$HOME/vanetza-deps \\ -DCMAKE_INSTALL_RPATH=\\$ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-dist \\ -DBUILD_SOCKTAP=ON \\ -DSOCKTAP_WITH_AUTOTALKS=ON make This builds the Vanetza libraries and socktap example as well. When you do make install , binaries are copied to $HOME/vanetza-dist . You can copy the binary with libraries to the Craton now. You should start the binary in the same directory as you would be running code from Autotalks examples (it needs their configuration files). You must run the binary with parameter -l autotalks for correct choosing of the link layer. Compiling for Secton We assume you have copy of the Vanetza repository in your home directory at $HOME . Furthermore, there should be a symbolic link named autotalks_secton_api in your home directory, that links to the root of Secton SDK (e.g., from /home/your_user/autotalks_secton_api to the API compilation directory). The build steps are then identical with the ones described in How to build . Just note that for using Autotalks SDK you should use enable compilation of socktap, e.g. like this: cmake .. \\ -DBUILD_SOCKTAP=ON \\ -DSOCKTAP_WITH_AUTOTALKS=ON make Binary then can be ran from the same directory you would be running the Autotalks example (it needs their configuration files). You must run the binary with parameter -l autotalks for correct choosing of the link layer.","title":"Building for Autotalks devices"},{"location":"recipes/autotalks-sdk-build/#building-vanetza-for-autotalks-craton-using-autotalks-sdk","text":"This document describes building Vanetza for the Autotalks device. There is a difference between building for Craton and Secton. Steps for building Vanetza for Autotalks Craton are very similar to build for Cohda MK5 devices (you can see steps in the building for Cohda MK5 document ). Difference is that there is no virtual machine provided from Autotalks. Autotalks SDK can used only in the socktap example, so you must always compile it when you want the SDK.","title":"Building Vanetza for Autotalks Craton using Autotalks SDK"},{"location":"recipes/autotalks-sdk-build/#autotalks-sdk","text":"SDK is shipped with Autotalks devices, you should have obtained one. Until Release 18, it was recommended to build the SDK in Ubuntu 16.04, now Ubuntu 18.04 or 20.04 should be used; it was tested on the latter. For Secton, there is used gcc version 9.4.0, for Craton arm-poky-linux-gnueabi-g++ version 11.2.0, that is installed with the poky container.","title":"Autotalks SDK"},{"location":"recipes/autotalks-sdk-build/#code-corrections","text":"With Autotalks SDK version <= 5.15.0, you will have to do a correction in file autotalks_*_api/include/atlk/ddm_service.h on line 615 and add there an explicit cast to stats_tlv_t * . Without this, you won\u2019t be able to build the project because of the -fpermissive flag. As of version 5.16.0, this problem is fixed. In version 5.17 (Release 18), there are another problems: * In autotalks_{craton,secton} api/include/common/counters.h change line 110 from uint8_t data[] to uint8_t* data * In autotalks {craton,secton}_api/include/atlk/generic_compensator.h, there is missing } for the extern \"C\" directive (this should be solved in newer SDK) Another thing you must note is in the initialization in the socktap example. The initialization code in v2x_device_init() was used directly from the example in the Autotalks SDK, therefore it should not be distributed with the library. You will have to write it yourself, but it really is almost the same as main() function in the basic example from the SDK. In the initialization, there is a define for SECTON_NET_NAME . This is a network interface name which determines how is the SoC seen in Linux. It should be enx0002ccf00006 by default, but if it is set to something else, you can change this define. You can use ifconfig output to determine the actual name (see Autotalks documentation for more details).","title":"Code corrections"},{"location":"recipes/autotalks-sdk-build/#vanetza-build-dependencies","text":"Please see this document about cross-compiling Vanetza\u2019s dependencies. This guide was tested with precompiled libraries downloadable from here .","title":"Vanetza build dependencies"},{"location":"recipes/autotalks-sdk-build/#compile-vanetza","text":"","title":"Compile Vanetza"},{"location":"recipes/autotalks-sdk-build/#compiling-for-craton","text":"We assume you have copy of the Vanetza repository in your home directory at $HOME . Furthermore, there should be a symbolic link named autotalks_craton_api in your home directory, that links to the root of Craton SDK (e.g., from /home/your_user/autotalks_craton_api to the API compilation directory). If you have Poky toolchain installed in other directory than /opt/poky-craton2/4.0.1 (e.g. /tools/gcc/arm/new_toolchain as suggested by Autotalks), change the path in cmake/Toolchain-Autotalks-Craton.cmake. Create a build directory and tell CMake to use the cross-compiler installed on your machine and to look up additional dependencies in vanetza-deps : mkdir vanetza/vanetza-build cd vanetza/vanetza-build cmake .. \\ -DCMAKE_TOOLCHAIN_FILE=../cmake/Toolchain-Autotalks-Craton.cmake \\ -DCMAKE_FIND_ROOT_PATH=$HOME/vanetza-deps \\ -DCMAKE_INSTALL_RPATH=\\$ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-dist \\ -DBUILD_SOCKTAP=ON \\ -DSOCKTAP_WITH_AUTOTALKS=ON make This builds the Vanetza libraries and socktap example as well. When you do make install , binaries are copied to $HOME/vanetza-dist . You can copy the binary with libraries to the Craton now. You should start the binary in the same directory as you would be running code from Autotalks examples (it needs their configuration files). You must run the binary with parameter -l autotalks for correct choosing of the link layer.","title":"Compiling for Craton"},{"location":"recipes/autotalks-sdk-build/#compiling-for-secton","text":"We assume you have copy of the Vanetza repository in your home directory at $HOME . Furthermore, there should be a symbolic link named autotalks_secton_api in your home directory, that links to the root of Secton SDK (e.g., from /home/your_user/autotalks_secton_api to the API compilation directory). The build steps are then identical with the ones described in How to build . Just note that for using Autotalks SDK you should use enable compilation of socktap, e.g. like this: cmake .. \\ -DBUILD_SOCKTAP=ON \\ -DSOCKTAP_WITH_AUTOTALKS=ON make Binary then can be ran from the same directory you would be running the Autotalks example (it needs their configuration files). You must run the binary with parameter -l autotalks for correct choosing of the link layer.","title":"Compiling for Secton"},{"location":"recipes/cohda-sdk-build/","text":"Building Vanetza for Cohda MK5 using Cohda SDK This document describes step-by-step how to build Vanetza using the Cohda SDK. At the end, we have Vanetza libraries and its socktap tool cross-compiled for Cohda MK5 devices. Cohda SDK Cohda SDK is provided by Cohda Wireless along with their MK5 units. Since you are reading this build how-to you most likely already possess one of these units. This how-to has been created for the Release 16 of the SDK. The following instructions are expected to be done within the virtual machine (VM) provided by Cohda. Please make sure that a recent GCC version for the arm-linux-gnueabihf target is installed in this VM. I recommend to deinstall g++-4.8-arm-linux-gnueabihf entirely as this version supports C++11 only poorly. g++-5-arm-linux-gnueabihf is known to work well. Vanetza build dependencies Compilation of Vanetza depends on several third-party libraries, e.g. Boost, GeographicLib and Crypto++ as mentioned in Vanetza\u2019s README. Steps to compile those dependencies are described in our cross-compile dependencies document . For the sake of simplicity, we provide the pre-compiled dependencies for Cohda MK5 as compressed archives. Archive Content MD5 checksum vanetza-deps-20171129.tar.bz2 Boost 1.65.1, GeographicLib 1.49, Crypto++ 5.6.5 853a2833fde0266674d4a4dbe22fe7ef vanetza-deps-20191126.tar.bz2 Boost 1.71.0, GeographicLib 1.50, Crypto++ 8.2.0 1d8832949673e3935f72aac6c00a132d At the moment, these archives are hosted on box.com . We recommend to download the most recent archive in general. Before the next step, extract the archive\u2019s content into /home/duser/vanetza-deps . Compile Vanetza We assume you have copy of the Vanetza repository in your home directory at /home/duser/vanetza . Create a build directory and tell CMake to use the cross-compiler installed in the Cohda VM and to look up additional dependencies in vanetza-deps : mkdir vanetza-build cd vanetza-build cmake $HOME/vanetza \\ -DCMAKE_TOOLCHAIN_FILE=$HOME/vanetza/cmake/Toolchain-Cohda-MK5.cmake \\ -DCMAKE_FIND_ROOT_PATH=$HOME/vanetza-deps \\ -DCMAKE_INSTALL_RPATH=\\$ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-dist make This builds the Vanetza libraries only. Enable the BUILD_SOCKTAP CMake option if you want to try socktap as well. Additionally, enable the SOCKTAP_WITH_COHDA_LLC CMake option if you want socktap to use 802.11p via Cohda\u2019s LLC network interface on your MK5. Fortunately, socktap \u2019s additional gpsd dependency is already shipped with the Cohda SDK itself. You only need to specify its location by setting GPS_LIBRARY to /home/duser/mk5/stack/v2x-lib/lib/mk5/libgps_static.a and GPS_INCLUDE_DIR to /home/duser/mk5/stack/v2x-lib/include . Please note, that socktap does not make use of Cohda\u2019s socket API currently. We might provide a modified socktap application in the future. Deployment make install Compile and link socktap with correct RPATH, binaries are copied to $HOME/vanetza-dist . copy runtime dependencies Copy the shared object files (*.so) from $HOME/vanetza-deps/libs onto the MK5, e.g. to /home/user/vanetza/lib . copy socktap onto MK5 Copy the files from $HOME/vanetza-dist to /home/user/vanetza on the MK5, i.e. Vanetza libraries and its dependency libraries are located in the same directory. You can execute socktap located at /home/user/vanetza/bin/socktap and it will look up its shared objects in the sibling lib directory. If you have enabled the SOCKTAP_WITH_COHDA_LLC CMake option, make sure to give socktap the name of a Cohda LLC network interface via the command line option --interface / -i (e.g. cw-llc0).","title":"Building for Cohda MK5"},{"location":"recipes/cohda-sdk-build/#building-vanetza-for-cohda-mk5-using-cohda-sdk","text":"This document describes step-by-step how to build Vanetza using the Cohda SDK. At the end, we have Vanetza libraries and its socktap tool cross-compiled for Cohda MK5 devices.","title":"Building Vanetza for Cohda MK5 using Cohda SDK"},{"location":"recipes/cohda-sdk-build/#cohda-sdk","text":"Cohda SDK is provided by Cohda Wireless along with their MK5 units. Since you are reading this build how-to you most likely already possess one of these units. This how-to has been created for the Release 16 of the SDK. The following instructions are expected to be done within the virtual machine (VM) provided by Cohda. Please make sure that a recent GCC version for the arm-linux-gnueabihf target is installed in this VM. I recommend to deinstall g++-4.8-arm-linux-gnueabihf entirely as this version supports C++11 only poorly. g++-5-arm-linux-gnueabihf is known to work well.","title":"Cohda SDK"},{"location":"recipes/cohda-sdk-build/#vanetza-build-dependencies","text":"Compilation of Vanetza depends on several third-party libraries, e.g. Boost, GeographicLib and Crypto++ as mentioned in Vanetza\u2019s README. Steps to compile those dependencies are described in our cross-compile dependencies document . For the sake of simplicity, we provide the pre-compiled dependencies for Cohda MK5 as compressed archives. Archive Content MD5 checksum vanetza-deps-20171129.tar.bz2 Boost 1.65.1, GeographicLib 1.49, Crypto++ 5.6.5 853a2833fde0266674d4a4dbe22fe7ef vanetza-deps-20191126.tar.bz2 Boost 1.71.0, GeographicLib 1.50, Crypto++ 8.2.0 1d8832949673e3935f72aac6c00a132d At the moment, these archives are hosted on box.com . We recommend to download the most recent archive in general. Before the next step, extract the archive\u2019s content into /home/duser/vanetza-deps .","title":"Vanetza build dependencies"},{"location":"recipes/cohda-sdk-build/#compile-vanetza","text":"We assume you have copy of the Vanetza repository in your home directory at /home/duser/vanetza . Create a build directory and tell CMake to use the cross-compiler installed in the Cohda VM and to look up additional dependencies in vanetza-deps : mkdir vanetza-build cd vanetza-build cmake $HOME/vanetza \\ -DCMAKE_TOOLCHAIN_FILE=$HOME/vanetza/cmake/Toolchain-Cohda-MK5.cmake \\ -DCMAKE_FIND_ROOT_PATH=$HOME/vanetza-deps \\ -DCMAKE_INSTALL_RPATH=\\$ORIGIN/../lib \\ -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-dist make This builds the Vanetza libraries only. Enable the BUILD_SOCKTAP CMake option if you want to try socktap as well. Additionally, enable the SOCKTAP_WITH_COHDA_LLC CMake option if you want socktap to use 802.11p via Cohda\u2019s LLC network interface on your MK5. Fortunately, socktap \u2019s additional gpsd dependency is already shipped with the Cohda SDK itself. You only need to specify its location by setting GPS_LIBRARY to /home/duser/mk5/stack/v2x-lib/lib/mk5/libgps_static.a and GPS_INCLUDE_DIR to /home/duser/mk5/stack/v2x-lib/include . Please note, that socktap does not make use of Cohda\u2019s socket API currently. We might provide a modified socktap application in the future.","title":"Compile Vanetza"},{"location":"recipes/cohda-sdk-build/#deployment","text":"make install Compile and link socktap with correct RPATH, binaries are copied to $HOME/vanetza-dist . copy runtime dependencies Copy the shared object files (*.so) from $HOME/vanetza-deps/libs onto the MK5, e.g. to /home/user/vanetza/lib . copy socktap onto MK5 Copy the files from $HOME/vanetza-dist to /home/user/vanetza on the MK5, i.e. Vanetza libraries and its dependency libraries are located in the same directory. You can execute socktap located at /home/user/vanetza/bin/socktap and it will look up its shared objects in the sibling lib directory. If you have enabled the SOCKTAP_WITH_COHDA_LLC CMake option, make sure to give socktap the name of a Cohda LLC network interface via the command line option --interface / -i (e.g. cw-llc0).","title":"Deployment"},{"location":"recipes/cross-compile-dependencies/","text":"Cross-Compilation of Dependencies This document summarises a few hints for cross-compiling Vanetza\u2019s dependencies. Please note, that cross-compiling is not relevant for you if you plan to use Vanetza on the same system you have built it on. Boost Create a configuration file for Boost.Build in your home directory at $HOME/user-config.jam and add following line to it: using gcc : arm : arm-linux-gnueabihf-g++ ; The install stage does not work in Boost 1.71.0 (and 1.70.0) when cross-compiling. A workaround for this issue is to remove following lines from tools/build/src/tools/common.jam (around line 976): # From GCC 5, versioning changes and minor becomes patch if $(tag) = gcc && [ numbers.less 4 $(version[1]) ] { version = $(version[1]) ; } # Ditto, from Clang 4 if ( $(tag) = clang || $(tag) = clangw ) && [ numbers.less 3 $(version[1]) ] { version = $(version[1]) ; } Then, the required libraries can be built and installed at given prefix path: ./b2 --prefix=$HOME/vanetza-deps --with-date_time --with-program_options --with-system --no-samples --no-tests variant=release link=shared cxxstd=11 install Crypto++ Version 8.2 can be cross-compiled with the provided GNUmakefile-cross makefile. export CXX=arm-linux-gnueabihf-g++ export PREFIX=$HOME/vanetza-deps export HAS_SOLIB_VERSION=1 make -f GNUmakefile-cross shared make -f GNUmakefile-cross install GeographicLib Following steps have been tested with version 1.50. $VANETZA refers to the root directory of this repository. mkdir build.arm cd build.arm cmake .. -DCMAKE_TOOLCHAIN_FILE=$VANETZA/cmake/Toolchain-Cohda-MK5.cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-deps make install","title":"Cross-Compilation of Dependencies"},{"location":"recipes/cross-compile-dependencies/#cross-compilation-of-dependencies","text":"This document summarises a few hints for cross-compiling Vanetza\u2019s dependencies. Please note, that cross-compiling is not relevant for you if you plan to use Vanetza on the same system you have built it on.","title":"Cross-Compilation of Dependencies"},{"location":"recipes/cross-compile-dependencies/#boost","text":"Create a configuration file for Boost.Build in your home directory at $HOME/user-config.jam and add following line to it: using gcc : arm : arm-linux-gnueabihf-g++ ; The install stage does not work in Boost 1.71.0 (and 1.70.0) when cross-compiling. A workaround for this issue is to remove following lines from tools/build/src/tools/common.jam (around line 976): # From GCC 5, versioning changes and minor becomes patch if $(tag) = gcc && [ numbers.less 4 $(version[1]) ] { version = $(version[1]) ; } # Ditto, from Clang 4 if ( $(tag) = clang || $(tag) = clangw ) && [ numbers.less 3 $(version[1]) ] { version = $(version[1]) ; } Then, the required libraries can be built and installed at given prefix path: ./b2 --prefix=$HOME/vanetza-deps --with-date_time --with-program_options --with-system --no-samples --no-tests variant=release link=shared cxxstd=11 install","title":"Boost"},{"location":"recipes/cross-compile-dependencies/#crypto","text":"Version 8.2 can be cross-compiled with the provided GNUmakefile-cross makefile. export CXX=arm-linux-gnueabihf-g++ export PREFIX=$HOME/vanetza-deps export HAS_SOLIB_VERSION=1 make -f GNUmakefile-cross shared make -f GNUmakefile-cross install","title":"Crypto++"},{"location":"recipes/cross-compile-dependencies/#geographiclib","text":"Following steps have been tested with version 1.50. $VANETZA refers to the root directory of this repository. mkdir build.arm cd build.arm cmake .. -DCMAKE_TOOLCHAIN_FILE=$VANETZA/cmake/Toolchain-Cohda-MK5.cmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=$HOME/vanetza-deps make install","title":"GeographicLib"},{"location":"recipes/cube-evk-build/","text":"Building for cube:evk The cube:evk from cubesys - an nfiniity company fully supports the Vanetza stack and its socktap application. An integrated V2X module listens for requests whether from a local or remote application. The communication protocol between host and V2X module is covered in Google\u2019s Protobuf that is used in the respective link-layer implementation. Configuration Before building and running socktap you need to configure the V2X module and the WiFi once. V2X Radio Configuration - C-V2X or DSRC First of all select your desired radio configuration using the v2xconfig tool on the cube:evk: # start dsrc or cv2x and enable auto-start cube> v2xconfig start enable dsrc Connect to your local WiFi This is only needed for the wireless remote radio mode. cube> sudo nmcli dev wifi connect '<ssid>' password '<password>' # get your ip cube> ip a Building and Running Socktap for Wireless Remote Radio Mode You can build and run socktap directly on your personal computer (host) and select cube-evk as link-layer. Further, gpsd daemon is running on the cube:evk that can feed socktap with GNSS data. In wireless remote radio mode you develop, debug and run Vanetza/socktap on your personal computer. There is no need to flash or transfer the application onto your cube:evk. The V2X radio on the cube:evk listens for incoming requests from remote. Both devices need to be pingable from each other only. host> mkdir build && cd build host> cmake -DBUILD_SOCKTAP=ON -DSOCKTAP_WITH_CUBE_EVK=ON .. # use fix position data host> ./bin/socktap -l cube-evk -p static --cube-ip <cube-ip> # use the ublox module on the cube:evk for positioning data host> ./bin/socktap -l cube-evk -p gpsd --gpsd-host <cube-ip> --cube-ip <cube-ip> Moreover, the integrated LTE module allows the user to do field tests with the cube:evk from remote. Building and Running Socktap on the cube:evk You can also build and run socktap on the cube:evk itself and it will connect to the local V2X module. cube> mkdir build && cd build cube> cmake -DBUILD_SOCKTAP=ON -DSOCKTAP_WITH_CUBE_EVK=ON .. # use fix position data cube> ./bin/socktap -l cube-evk -p static # use the ublox module on the cube:evk for positioning data cube> ./bin/socktap -l cube-evk -p gpsd --gpsd-host 127.0.0.1","title":"Building for cube:evk"},{"location":"recipes/cube-evk-build/#building-for-cubeevk","text":"The cube:evk from cubesys - an nfiniity company fully supports the Vanetza stack and its socktap application. An integrated V2X module listens for requests whether from a local or remote application. The communication protocol between host and V2X module is covered in Google\u2019s Protobuf that is used in the respective link-layer implementation.","title":"Building for cube:evk"},{"location":"recipes/cube-evk-build/#configuration","text":"Before building and running socktap you need to configure the V2X module and the WiFi once.","title":"Configuration"},{"location":"recipes/cube-evk-build/#v2x-radio-configuration-c-v2x-or-dsrc","text":"First of all select your desired radio configuration using the v2xconfig tool on the cube:evk: # start dsrc or cv2x and enable auto-start cube> v2xconfig start enable dsrc","title":"V2X Radio Configuration - C-V2X or DSRC"},{"location":"recipes/cube-evk-build/#connect-to-your-local-wifi","text":"This is only needed for the wireless remote radio mode. cube> sudo nmcli dev wifi connect '<ssid>' password '<password>' # get your ip cube> ip a","title":"Connect to your local WiFi"},{"location":"recipes/cube-evk-build/#building-and-running-socktap-for-wireless-remote-radio-mode","text":"You can build and run socktap directly on your personal computer (host) and select cube-evk as link-layer. Further, gpsd daemon is running on the cube:evk that can feed socktap with GNSS data. In wireless remote radio mode you develop, debug and run Vanetza/socktap on your personal computer. There is no need to flash or transfer the application onto your cube:evk. The V2X radio on the cube:evk listens for incoming requests from remote. Both devices need to be pingable from each other only. host> mkdir build && cd build host> cmake -DBUILD_SOCKTAP=ON -DSOCKTAP_WITH_CUBE_EVK=ON .. # use fix position data host> ./bin/socktap -l cube-evk -p static --cube-ip <cube-ip> # use the ublox module on the cube:evk for positioning data host> ./bin/socktap -l cube-evk -p gpsd --gpsd-host <cube-ip> --cube-ip <cube-ip> Moreover, the integrated LTE module allows the user to do field tests with the cube:evk from remote.","title":"Building and Running Socktap for Wireless Remote Radio Mode"},{"location":"recipes/cube-evk-build/#building-and-running-socktap-on-the-cubeevk","text":"You can also build and run socktap on the cube:evk itself and it will connect to the local V2X module. cube> mkdir build && cd build cube> cmake -DBUILD_SOCKTAP=ON -DSOCKTAP_WITH_CUBE_EVK=ON .. # use fix position data cube> ./bin/socktap -l cube-evk -p static # use the ublox module on the cube:evk for positioning data cube> ./bin/socktap -l cube-evk -p gpsd --gpsd-host 127.0.0.1","title":"Building and Running Socktap on the cube:evk"},{"location":"tools/benchmark/","text":"Benchmark Benchmark is a tool to benchmark some components of Vanetza. At the moment, benchmarks for signing and validating packets exist. Installation Benchmarks are not built by default, so you need to enable them explicitly. Run cmake -D BUILD_BENCHMARK=ON .. in your build directory to do so and start the build process again. You should be able to find bin/benchmark in your build directory afterwards. Running You can run bin/benchmark --help to get a list of available benchmarks. You can run these with bin/benchmark <name> then. Acknowledgement This application has been initially developed Niklas Keller .","title":"Benchmark"},{"location":"tools/benchmark/#benchmark","text":"Benchmark is a tool to benchmark some components of Vanetza. At the moment, benchmarks for signing and validating packets exist.","title":"Benchmark"},{"location":"tools/benchmark/#installation","text":"Benchmarks are not built by default, so you need to enable them explicitly. Run cmake -D BUILD_BENCHMARK=ON .. in your build directory to do so and start the build process again. You should be able to find bin/benchmark in your build directory afterwards.","title":"Installation"},{"location":"tools/benchmark/#running","text":"You can run bin/benchmark --help to get a list of available benchmarks. You can run these with bin/benchmark <name> then.","title":"Running"},{"location":"tools/benchmark/#acknowledgement","text":"This application has been initially developed Niklas Keller .","title":"Acknowledgement"},{"location":"tools/certify/","text":"Certify Certify is a tool to create and view certificates and can be used to set up a test PKI for secured V2X communication based on TS 103 097 v1.2.1. Installation You need to enable building this tool explicitly. Run cmake -D BUILD_CERTIFY=ON .. in your build directory and rebuild Vanetza. You should be able to find bin/certify in your build directory afterwards. PKI Setup The following section describe how to setup a test PKI. We will generate a root certificate, an authorization authority certificate and an authorization ticket. Generating Keys New private keys can be generated using bin/certify generate-key root.key . The corresponding public key can be extracted using bin/certify extract-public-key --private-key root.key root.pub , but this step usually isn\u2019t required. Please generate a root.key for the root certificate, a aa.key for the authorization authority and a ticket.key for the authorization ticket. Generating Root Certificates A root certificate can be generated using bin/certify generate-root --subject-key root.key root.cert . Generating Authorization Authorities An authorization authority certificate can be generated using bin/certify generate-aa --sign-key root.key --sign-cert root.cert --subject-key aa.key aa.cert . Generating Authorization Tickets An authorization ticket can be generated using bin/certify generate-ticket --sign-key aa.key --sign-cert aa.cert --subject-key ticket.key ticket.cert . If you\u2019re generating a certificate for real V2X hardware, it will likely use a hardware security module (HSM), which will only expose the public key. You can export the given public key to a file and use --subject-key also with public keys. The public key needs to be encoded according to the rules specified by ETSI in TS 103 097 v1.2.1. Other Options This guide only uses the required options. Further options may be available for certain commands. Use bin/certify <command> --help for further information. Acknowledgement This application has been initially developed Niklas Keller .","title":"Certify"},{"location":"tools/certify/#certify","text":"Certify is a tool to create and view certificates and can be used to set up a test PKI for secured V2X communication based on TS 103 097 v1.2.1.","title":"Certify"},{"location":"tools/certify/#installation","text":"You need to enable building this tool explicitly. Run cmake -D BUILD_CERTIFY=ON .. in your build directory and rebuild Vanetza. You should be able to find bin/certify in your build directory afterwards.","title":"Installation"},{"location":"tools/certify/#pki-setup","text":"The following section describe how to setup a test PKI. We will generate a root certificate, an authorization authority certificate and an authorization ticket.","title":"PKI Setup"},{"location":"tools/certify/#generating-keys","text":"New private keys can be generated using bin/certify generate-key root.key . The corresponding public key can be extracted using bin/certify extract-public-key --private-key root.key root.pub , but this step usually isn\u2019t required. Please generate a root.key for the root certificate, a aa.key for the authorization authority and a ticket.key for the authorization ticket.","title":"Generating Keys"},{"location":"tools/certify/#generating-root-certificates","text":"A root certificate can be generated using bin/certify generate-root --subject-key root.key root.cert .","title":"Generating Root Certificates"},{"location":"tools/certify/#generating-authorization-authorities","text":"An authorization authority certificate can be generated using bin/certify generate-aa --sign-key root.key --sign-cert root.cert --subject-key aa.key aa.cert .","title":"Generating Authorization Authorities"},{"location":"tools/certify/#generating-authorization-tickets","text":"An authorization ticket can be generated using bin/certify generate-ticket --sign-key aa.key --sign-cert aa.cert --subject-key ticket.key ticket.cert . If you\u2019re generating a certificate for real V2X hardware, it will likely use a hardware security module (HSM), which will only expose the public key. You can export the given public key to a file and use --subject-key also with public keys. The public key needs to be encoded according to the rules specified by ETSI in TS 103 097 v1.2.1.","title":"Generating Authorization Tickets"},{"location":"tools/certify/#other-options","text":"This guide only uses the required options. Further options may be available for certain commands. Use bin/certify <command> --help for further information.","title":"Other Options"},{"location":"tools/certify/#acknowledgement","text":"This application has been initially developed Niklas Keller .","title":"Acknowledgement"},{"location":"tools/fuzz-harness/","text":"fuzz-harness The fuzz harness for Vanetza is a testing tool designed to identify bugs, vulnerabilities, and unexpected behaviors within Vanetza\u2019s codebase. Fuzz testing, also known as fuzzing, involves providing invalid, unexpected, or random data as input to a program to uncover errors or security issues. Requirements You will need AFL++ installed on your system. Please refer to the AFL++ documentation for installation instructions. Alternatively, you can use the scripts located at tools/fuzz-harness for running fuzz tests in a Docker container. Usage Running the script fuzz-harness/docker.sh will build a suitable Docker container based on the official aflplusplus/aflplusplus image. As soon as the container is ready, the script launches the built container and maps your local user and some Vanetza directories into it. Within the container, you can compile the fuzz-harness using the AFL++ toolchain by invoking the compile.sh script. The fuzz.sh script is a convenient way to run the built harness with afl-fuzz . If it crashes immediately, try again a few times. Analyse Fuzzing is executing the fuzzing-persistent executable. You can use its sibling fuzzing-run to investigate a particular crash and get more information about the possible problems. The address sanitizer is enabled by default. If you\u2019re not interested in memory leaks, make sure to disable the leak sanatizer by setting the environment variable ASAN_OPTIONS=detect_leaks=0 . You may also want to classify the found issues using casr-afl : casr-afl -i output -o output/casr The classification process also eliminates duplicate issues.","title":"fuzz-harness"},{"location":"tools/fuzz-harness/#fuzz-harness","text":"The fuzz harness for Vanetza is a testing tool designed to identify bugs, vulnerabilities, and unexpected behaviors within Vanetza\u2019s codebase. Fuzz testing, also known as fuzzing, involves providing invalid, unexpected, or random data as input to a program to uncover errors or security issues.","title":"fuzz-harness"},{"location":"tools/fuzz-harness/#requirements","text":"You will need AFL++ installed on your system. Please refer to the AFL++ documentation for installation instructions. Alternatively, you can use the scripts located at tools/fuzz-harness for running fuzz tests in a Docker container.","title":"Requirements"},{"location":"tools/fuzz-harness/#usage","text":"Running the script fuzz-harness/docker.sh will build a suitable Docker container based on the official aflplusplus/aflplusplus image. As soon as the container is ready, the script launches the built container and maps your local user and some Vanetza directories into it. Within the container, you can compile the fuzz-harness using the AFL++ toolchain by invoking the compile.sh script. The fuzz.sh script is a convenient way to run the built harness with afl-fuzz . If it crashes immediately, try again a few times.","title":"Usage"},{"location":"tools/fuzz-harness/#analyse","text":"Fuzzing is executing the fuzzing-persistent executable. You can use its sibling fuzzing-run to investigate a particular crash and get more information about the possible problems. The address sanitizer is enabled by default. If you\u2019re not interested in memory leaks, make sure to disable the leak sanatizer by setting the environment variable ASAN_OPTIONS=detect_leaks=0 . You may also want to classify the found issues using casr-afl : casr-afl -i output -o output/casr The classification process also eliminates duplicate issues.","title":"Analyse"},{"location":"tools/socktap/","text":"Socktap socktap is an example application demonstrating API usage of Vanetza libraries. You can run this demo application on commodity hardware, i.e. no special V2X or Car2X hardware is required. If you have an IEEE 802.11p compatible network interface card, though, socktap can also communicate with other ITS-G5 stations. Consider socktap as an experimental application showcasing some of Vanetza\u2019s features but not as a full-grown ITS-G5 station. However, socktap may be the starting point for your custom application. Just keep in mind that Vanetza supports more features than those integrated in socktap . For example, socktap omits Decentralized Congestion Control (DCC) entirely though Vanetza supports this feature. Link layer At the moment, six link layer implementations exist for socktap . You can choose via the --link-layer argument which implementation to use: ethernet runs on Linux raw packet sockets cube-evk runs nfiniity\u2019s link-layer implementation for the cube-evk autotalks uses the Autotalks API to run on Autotalks hardware cohda employs Cohda\u2019s LLC API udp runs GeoNetworking on top of IP/UDP multicast sockets tcp runs GeoNetworking on top of IP/TCP sockets rpc uses Cap\u2019n Proto interchange format and RPC with external server Ethernet The ethernet variant has been initially socktap \u2019s only available link-layer implementation. In this mode, socktap will send and receiver Ethernet frames on the specified network interface (see --interface argument). Please be aware that socktap needs special privileges to access the raw sockets. Either run socktap as root user or set the CAP_NET_RAW capabilities on the socktap executable. You can do this via sudo setcap cap_net_raw+ep bin/socktap . When CAP_NET_RAW is attached to the socktap binary you can run it as an ordinary user. CUBE-EVK If you have access to a cube-evk from nfiniity you can use socktap on your personal computer and connect to the EVK. In this mode the EVK is used as wireless remote radio. Moreover, you can use socktap on the EVK natively as well. Please refer to our Running socktap on nfiniity devices for more details. Cohda If you have access to V2X hardware from Cohda Wireless, you can also run socktap on their units. In the cohda mode, socktap uses Cohda\u2019s LLC API for sending and receiving data frames. This mode is similar to ethernet but depends on the Cohda SDK. Please refer to our Cohda SDK building recipe for details. Autotalks Another option involving dedicated V2X hardware uses the Autotalks API. Please have a look at our Building for Autotalks devices guide how to incorporate the Autotalks SDK. [!WARNING] Our Autotalks link layer integration is deprecated. Please use the RPC link layer as a superior replacement. UDP A relatively new addition is the udp mode, which allows running socktap without any privileges. GeoNetworking packets are wrapped into UDP datagrams and sent to the IP multicast group 239.118.122.97 on UDP port 8947 . Further socktap instances within the same IP multicast network exchange GeoNetworking packets then. You can consider this as \u201cGeoNetworking over IP/UDP\u201d. TCP The TCP implementation is similiar to the UDP one. However, TCP adds the arguments --tcp-accept and --tcp-connect , which allow the user to accept incoming TCP connections or connect to open TCP sockets, respectively. Both arguments expect a comma separated list of ip:port . Outgoing GeoNetworking packets will then be sent to all active TCP connections. RPC RPC link layer lets socktap connect to an external RPC server over Cap\u2019n Proto . You can refer to MACH SYSTEMS\u2019s RPC link for developing the server on your own V2X hardware, e.g. Autotalks EVKs. The cube V2X devices ship a compatible cube-radio-rpc service with cube:os 1.4 and later. Command line flags --rpc-host <HOST> \u2013\u2060\u2060\u2060\u2060\u2060 hostname or IP of the RPC server (default: localhost ) --rpc-port <PORT> \u2013\u2060\u2060\u2060\u2060\u2060\u2060 TCP port on which the server is listening (default: 23057 ) --rpc-radio-technology <TECH> \u2013\u2060\u2060\u2060\u2060 radio technology to advertise to the server; valid values: ITS-G5 \u2013\u2060\u2060\u2060\u2060\u2060\u2060 802.11p / bd LTE-V2X|C-V2X \u2013\u2060\u2060\u2060\u2060\u2060\u2060 LTE-V2X / 5G-V2X --rpc-debug \u2013\u2060\u2060\u2060\u2060\u2060\u2060 enable debugging output Positioning Many components of an ITS-G5 system depend on positioning data. Ideally, you have a GPS receiver attached to the computer running gpsd along with socktap . If you do not have a GPS receiver or no GPS signal in your environment, you can also set a static position manually. The --positioning argument controls if gpsd provides live GPS position fixes or if socktap shall use a static position fix. See also the --latitude and --longitude arguments for the latter option. Applications Earlier, multiple variants of socktap existed as separate executables. Nowadays, socktap is the unified executable which can be configured in many ways. These configuration options substitute the deprecated executables. You can choose from three simple example V2X applications to run with socktap via the --applications argument: ca sends Cooperative Awareness Messages (CAM) hello sends simple BTP-B message with the binary payload 0xc0ffee benchmark counts the number of any received messages and prints the current message rate once per second Building and Running You need to enable the CMake option BUILD_SOCKTAP so socktap will be built at all. Two further CMake options control which optional features are included into the socktap executable. Build options First, the option SOCKTAP_WITH_COHDA_LLC enables the link-layer variant for operation on Cohda V2X devices. This option usually makes only sense if you are cross-compiling socktap for a Cohda device. If CMake finds gpsd on your system, the option SOCKTAP_WITH_GPSD is enabled by default. The integration of GPS receivers depends on this option. If this option is disabled, you can only configure static positions with socktap . Warning A bug in gpsd<=3.15 causes a segmentation fault when socktap tries to fetch GPS data. More recent versions include a bugfix, e.g. gpsd>=3.17 is known to work. See also the corresponding issue ticket #69 . First steps You can locate socktap in your build directory at bin/socktap . Run this executable with --help appended to see the list of available runtime configuration options. With the ethernet link-layer you should specify the network device on which socktap should send and receive packets via --interface . Usually, such devices are named eth0 or wlan0 . You can look up the available devices on your machine with the ip link command. If you want to use the local loopback device (usually lo ) you need to override the used MAC address using --mac-address to receive packets. Otherwise, the MAC address is 00:00:00:00:00:00 for both sides and the router drops incoming packets matching its address. Acknowledgement This demo application has been initially developed as part of a student\u2019s project at Hochschule Darmstadt in summer term 2016. Participating students were in alphabetical order: Sachin Kashyap Bukkambudhi Satyanarayana, Alvita Marina Menezes, Mrunmayi Parchure, Subashini Rajan and Deeksha Venkadari Yogendra. Since then, @kelunik and @glmax have contributed a lot to socktap .","title":"Socktap"},{"location":"tools/socktap/#socktap","text":"socktap is an example application demonstrating API usage of Vanetza libraries. You can run this demo application on commodity hardware, i.e. no special V2X or Car2X hardware is required. If you have an IEEE 802.11p compatible network interface card, though, socktap can also communicate with other ITS-G5 stations. Consider socktap as an experimental application showcasing some of Vanetza\u2019s features but not as a full-grown ITS-G5 station. However, socktap may be the starting point for your custom application. Just keep in mind that Vanetza supports more features than those integrated in socktap . For example, socktap omits Decentralized Congestion Control (DCC) entirely though Vanetza supports this feature.","title":"Socktap"},{"location":"tools/socktap/#link-layer","text":"At the moment, six link layer implementations exist for socktap . You can choose via the --link-layer argument which implementation to use: ethernet runs on Linux raw packet sockets cube-evk runs nfiniity\u2019s link-layer implementation for the cube-evk autotalks uses the Autotalks API to run on Autotalks hardware cohda employs Cohda\u2019s LLC API udp runs GeoNetworking on top of IP/UDP multicast sockets tcp runs GeoNetworking on top of IP/TCP sockets rpc uses Cap\u2019n Proto interchange format and RPC with external server","title":"Link layer"},{"location":"tools/socktap/#ethernet","text":"The ethernet variant has been initially socktap \u2019s only available link-layer implementation. In this mode, socktap will send and receiver Ethernet frames on the specified network interface (see --interface argument). Please be aware that socktap needs special privileges to access the raw sockets. Either run socktap as root user or set the CAP_NET_RAW capabilities on the socktap executable. You can do this via sudo setcap cap_net_raw+ep bin/socktap . When CAP_NET_RAW is attached to the socktap binary you can run it as an ordinary user.","title":"Ethernet"},{"location":"tools/socktap/#cube-evk","text":"If you have access to a cube-evk from nfiniity you can use socktap on your personal computer and connect to the EVK. In this mode the EVK is used as wireless remote radio. Moreover, you can use socktap on the EVK natively as well. Please refer to our Running socktap on nfiniity devices for more details.","title":"CUBE-EVK"},{"location":"tools/socktap/#cohda","text":"If you have access to V2X hardware from Cohda Wireless, you can also run socktap on their units. In the cohda mode, socktap uses Cohda\u2019s LLC API for sending and receiving data frames. This mode is similar to ethernet but depends on the Cohda SDK. Please refer to our Cohda SDK building recipe for details.","title":"Cohda"},{"location":"tools/socktap/#autotalks","text":"Another option involving dedicated V2X hardware uses the Autotalks API. Please have a look at our Building for Autotalks devices guide how to incorporate the Autotalks SDK. [!WARNING] Our Autotalks link layer integration is deprecated. Please use the RPC link layer as a superior replacement.","title":"Autotalks"},{"location":"tools/socktap/#udp","text":"A relatively new addition is the udp mode, which allows running socktap without any privileges. GeoNetworking packets are wrapped into UDP datagrams and sent to the IP multicast group 239.118.122.97 on UDP port 8947 . Further socktap instances within the same IP multicast network exchange GeoNetworking packets then. You can consider this as \u201cGeoNetworking over IP/UDP\u201d.","title":"UDP"},{"location":"tools/socktap/#tcp","text":"The TCP implementation is similiar to the UDP one. However, TCP adds the arguments --tcp-accept and --tcp-connect , which allow the user to accept incoming TCP connections or connect to open TCP sockets, respectively. Both arguments expect a comma separated list of ip:port . Outgoing GeoNetworking packets will then be sent to all active TCP connections.","title":"TCP"},{"location":"tools/socktap/#rpc","text":"RPC link layer lets socktap connect to an external RPC server over Cap\u2019n Proto . You can refer to MACH SYSTEMS\u2019s RPC link for developing the server on your own V2X hardware, e.g. Autotalks EVKs. The cube V2X devices ship a compatible cube-radio-rpc service with cube:os 1.4 and later.","title":"RPC"},{"location":"tools/socktap/#command-line-flags","text":"--rpc-host <HOST> \u2013\u2060\u2060\u2060\u2060\u2060 hostname or IP of the RPC server (default: localhost ) --rpc-port <PORT> \u2013\u2060\u2060\u2060\u2060\u2060\u2060 TCP port on which the server is listening (default: 23057 ) --rpc-radio-technology <TECH> \u2013\u2060\u2060\u2060\u2060 radio technology to advertise to the server; valid values: ITS-G5 \u2013\u2060\u2060\u2060\u2060\u2060\u2060 802.11p / bd LTE-V2X|C-V2X \u2013\u2060\u2060\u2060\u2060\u2060\u2060 LTE-V2X / 5G-V2X --rpc-debug \u2013\u2060\u2060\u2060\u2060\u2060\u2060 enable debugging output","title":"Command line flags"},{"location":"tools/socktap/#positioning","text":"Many components of an ITS-G5 system depend on positioning data. Ideally, you have a GPS receiver attached to the computer running gpsd along with socktap . If you do not have a GPS receiver or no GPS signal in your environment, you can also set a static position manually. The --positioning argument controls if gpsd provides live GPS position fixes or if socktap shall use a static position fix. See also the --latitude and --longitude arguments for the latter option.","title":"Positioning"},{"location":"tools/socktap/#applications","text":"Earlier, multiple variants of socktap existed as separate executables. Nowadays, socktap is the unified executable which can be configured in many ways. These configuration options substitute the deprecated executables. You can choose from three simple example V2X applications to run with socktap via the --applications argument: ca sends Cooperative Awareness Messages (CAM) hello sends simple BTP-B message with the binary payload 0xc0ffee benchmark counts the number of any received messages and prints the current message rate once per second","title":"Applications"},{"location":"tools/socktap/#building-and-running","text":"You need to enable the CMake option BUILD_SOCKTAP so socktap will be built at all. Two further CMake options control which optional features are included into the socktap executable.","title":"Building and Running"},{"location":"tools/socktap/#build-options","text":"First, the option SOCKTAP_WITH_COHDA_LLC enables the link-layer variant for operation on Cohda V2X devices. This option usually makes only sense if you are cross-compiling socktap for a Cohda device. If CMake finds gpsd on your system, the option SOCKTAP_WITH_GPSD is enabled by default. The integration of GPS receivers depends on this option. If this option is disabled, you can only configure static positions with socktap . Warning A bug in gpsd<=3.15 causes a segmentation fault when socktap tries to fetch GPS data. More recent versions include a bugfix, e.g. gpsd>=3.17 is known to work. See also the corresponding issue ticket #69 .","title":"Build options"},{"location":"tools/socktap/#first-steps","text":"You can locate socktap in your build directory at bin/socktap . Run this executable with --help appended to see the list of available runtime configuration options. With the ethernet link-layer you should specify the network device on which socktap should send and receive packets via --interface . Usually, such devices are named eth0 or wlan0 . You can look up the available devices on your machine with the ip link command. If you want to use the local loopback device (usually lo ) you need to override the used MAC address using --mac-address to receive packets. Otherwise, the MAC address is 00:00:00:00:00:00 for both sides and the router drops incoming packets matching its address.","title":"First steps"},{"location":"tools/socktap/#acknowledgement","text":"This demo application has been initially developed as part of a student\u2019s project at Hochschule Darmstadt in summer term 2016. Participating students were in alphabetical order: Sachin Kashyap Bukkambudhi Satyanarayana, Alvita Marina Menezes, Mrunmayi Parchure, Subashini Rajan and Deeksha Venkadari Yogendra. Since then, @kelunik and @glmax have contributed a lot to socktap .","title":"Acknowledgement"}]}